<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guide d'Achat PC Portable MSI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 50%, #2a2a2a 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 80%, rgba(204, 0, 0, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(0, 162, 255, 0.02) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(255, 0, 127, 0.02) 0%, transparent 50%);
            pointer-events: none;
            z-index: -1;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 20px;
            box-shadow: 
                0 30px 60px rgba(0,0,0,0.4),
                0 0 0 1px rgba(204, 0, 0, 0.1);
            overflow: visible;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(204, 0, 0, 0.1);
        }

        header {
            background: linear-gradient(135deg, #000000 0%, #1a1a1a 50%, #2a2a2a 100%);
            color: white;
            padding: 40px 50px;
            position: relative;
            overflow: visible;
        }

        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="tech" width="20" height="20" patternUnits="userSpaceOnUse"><path d="M 0 0 L 20 0 L 20 20 L 0 20 Z" fill="none" stroke="rgba(255,255,255,0.02)" stroke-width="0.5"/><circle cx="10" cy="10" r="1" fill="rgba(255,255,255,0.03)"/></pattern></defs><rect width="100" height="100" fill="url(%23tech)"/></svg>'),
                linear-gradient(45deg, transparent 30%, rgba(204,0,0,0.05) 50%, transparent 70%);
            animation: techPattern 25s linear infinite;
        }

        @keyframes techPattern {
            0% { transform: translateX(0) translateY(0); }
            100% { transform: translateX(20px) translateY(20px); }
        }

        .header-content {
            position: relative;
            z-index: 2;
            display: flex;
            align-items: center;
            gap: 30px;
        }

        .header-title {
            flex: 1;
        }

        h1 {
            font-size: 3.2rem;
            margin: 0;
            font-weight: 700;
            text-shadow: 0 3px 6px rgba(0,0,0,0.5);
            background: linear-gradient(45deg, #ffffff 0%, #f0f0f0 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: 1px;
        }

        .main-content {
            padding: 50px 40px;
        }

        .section {
            margin-bottom: 50px;
            padding: 40px;
            background: linear-gradient(135deg, #fafafa 0%, #f5f5f5 100%);
            border-radius: 20px;
            border-left: 6px solid #CC0000;
            box-shadow: 
                0 10px 30px rgba(0,0,0,0.1),
                inset 0 1px 0 rgba(255,255,255,0.8);
            position: relative;
            overflow: visible;
        }

        .section::before {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 200px;
            height: 100%;
            background: linear-gradient(90deg, transparent 0%, rgba(204, 0, 0, 0.02) 100%);
            pointer-events: none;
        }

        h2 {
            color: #1a1a1a;
            margin-bottom: 30px;
            font-size: 2.2rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            position: relative;
            z-index: 1;
        }

        h2::before {
            content: "‚öôÔ∏è";
            margin-right: 15px;
            font-size: 1.6rem;
            filter: drop-shadow(0 2px 4px rgba(204, 0, 0, 0.3));
        }

        .usage-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 25px;
            margin-bottom: 40px;
        }

        .usage-card {
            background: linear-gradient(135deg, #ffffff 0%, #fafafa 100%);
            border: 2px solid #e8e8e8;
            border-radius: 16px;
            padding: 30px 25px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: center;
            position: relative;
            box-shadow: 
                0 4px 15px rgba(0,0,0,0.08),
                inset 0 1px 0 rgba(255,255,255,0.8);
            overflow: visible;
        }

        .usage-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, 
                rgba(204, 0, 0, 0.05) 0%, 
                rgba(0, 162, 255, 0.03) 50%, 
                rgba(255, 0, 127, 0.03) 100%);
            opacity: 0;
            transition: opacity 0.4s ease;
            pointer-events: none;
        }

        .usage-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 
                0 15px 35px rgba(0,0,0,0.15),
                0 0 0 1px rgba(204, 0, 0, 0.1),
                inset 0 1px 0 rgba(255,255,255,0.9);
            border-color: #CC0000;
        }

        .usage-card:hover::before {
            opacity: 1;
        }

        .usage-card.selected {
            border-color: #CC0000;
            background: linear-gradient(135deg, #ffffff 0%, #fafafa 100%);
            box-shadow: 
                0 15px 35px rgba(204, 0, 0, 0.25),
                0 0 0 2px rgba(204, 0, 0, 0.2),
                inset 0 1px 0 rgba(255,255,255,0.9);
            transform: translateY(-5px);
        }

        .usage-card.selected::before {
            opacity: 1;
        }

        .usage-number {
            position: absolute;
            top: -12px;
            left: -12px;
            background: linear-gradient(135deg, #CC0000 0%, #AA0000 100%);
            color: white;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1rem;
            box-shadow: 
                0 5px 15px rgba(204, 0, 0, 0.4),
                0 0 0 3px rgba(255, 255, 255, 0.9);
            border: 2px solid white;
        }

        .usage-card.selected .usage-number {
            display: flex;
            animation: popIn 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        @keyframes popIn {
            0% { transform: scale(0) rotate(-180deg); opacity: 0; }
            80% { transform: scale(1.1) rotate(-10deg); opacity: 1; }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        .usage-icon {
            width: 80px;
            height: 80px;
            margin: 0 auto 18px;
            display: block;
            border-radius: 12px;
            object-fit: cover;
            filter: drop-shadow(0 4px 12px rgba(0,0,0,0.15));
            transition: transform 0.3s ease;
        }

        .usage-card:hover .usage-icon {
            transform: scale(1.05);
        }

        .usage-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 12px;
            color: #1a1a1a;
            line-height: 1.3;
        }

        .usage-desc {
            font-size: 0.95rem;
            opacity: 0.7;
            line-height: 1.5;
            color: #555;
        }

        .generate-btn {
            background: linear-gradient(135deg, #CC0000 0%, #AA0000 50%, #880000 100%);
            color: white;
            border: none;
            padding: 20px 50px;
            border-radius: 50px;
            font-size: 1.2rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 
                0 8px 25px rgba(204, 0, 0, 0.3),
                inset 0 1px 0 rgba(255,255,255,0.2);
            position: relative;
            overflow: visible;
        }

        .generate-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.6s;
        }

        .generate-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #AA0000 0%, #880000 50%, #660000 100%);
            transform: translateY(-3px);
            box-shadow: 
                0 12px 35px rgba(204, 0, 0, 0.4),
                inset 0 1px 0 rgba(255,255,255,0.3);
        }

        .generate-btn:hover:not(:disabled)::before {
            left: 100%;
        }

        .generate-btn:disabled {
            background: linear-gradient(135deg, #999 0%, #777 100%);
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .reset-btn {
            background: linear-gradient(135deg, #666 0%, #555 100%);
            color: white;
            border: none;
            padding: 15px 35px;
            border-radius: 25px;
            margin-left: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .reset-btn:hover {
            background: linear-gradient(135deg, #555 0%, #444 100%);
            transform: translateY(-2px);
        }

        .config-card {
            background: linear-gradient(135deg, #ffffff 0%, #fafafa 100%);
            border-radius: 20px;
            padding: 35px;
            box-shadow: 
                0 10px 30px rgba(0,0,0,0.15),
                inset 0 1px 0 rgba(255,255,255,0.8);
            border-top: 6px solid #CC0000;
            transition: all 0.3s ease;
            position: relative;
            overflow: visible;
        }

        .config-card::before {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 100px;
            height: 100%;
            background: linear-gradient(90deg, transparent 0%, rgba(204, 0, 0, 0.03) 100%);
            pointer-events: none;
        }

        .config-card:hover {
            transform: translateY(-5px);
            box-shadow: 
                0 20px 40px rgba(0,0,0,0.2),
                inset 0 1px 0 rgba(255,255,255,0.9);
        }

        .config-card.minimum {
            border-top-color: #FFA500;
        }

        .config-card.minimum::before {
            background: linear-gradient(90deg, transparent 0%, rgba(255, 165, 0, 0.03) 100%);
        }

        .config-card.recommande {
            border-top-color: #28a745;
        }

        .config-card.recommande::before {
            background: linear-gradient(90deg, transparent 0%, rgba(40, 167, 69, 0.03) 100%);
        }

        .config-card.ideal {
            border-top-color: #CC0000;
            background: linear-gradient(135deg, #ffffff 0%, #fafafa 100%);
        }

        .config-title {
            font-size: 1.6rem;
            margin-bottom: 18px;
            color: #1a1a1a;
            display: flex;
            align-items: center;
            font-weight: 600;
            position: relative;
            z-index: 1;
        }

        .config-title::before {
            margin-right: 15px;
            font-size: 1.4rem;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
        }

        .minimum .config-title::before { content: "‚ö°"; }
        .recommande .config-title::before { content: "üèÜ"; }
        .ideal .config-title::before { content: "üíé"; }

        .category-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #1a1a1a;
            margin-bottom: 18px;
            padding-bottom: 10px;
            border-bottom: 2px solid #CC0000;
            display: flex;
            align-items: center;
            position: relative;
        }

        .category-title::before {
            margin-right: 10px;
            font-size: 1.1rem;
            filter: drop-shadow(0 1px 3px rgba(204, 0, 0, 0.3));
        }

        .spec-item {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 12px 0;
            border-bottom: 1px solid #f0f0f0;
            transition: background-color 0.2s ease;
        }

        .spec-item:hover {
            background-color: rgba(204, 0, 0, 0.02);
            border-radius: 6px;
            padding-left: 8px;
            padding-right: 8px;
        }

        .spec-item:last-child {
            border-bottom: none;
        }

        .spec-label {
            font-weight: 600;
            color: #555;
            flex: 1.2;
            margin-right: 20px;
            line-height: 1.4;
        }

        .spec-value {
            flex: 1.5;
            text-align: right;
            color: #1a1a1a;
            font-weight: 500;
            line-height: 1.4;
        }

        .msi-recommendation {
            background: linear-gradient(135deg, #fff 0%, #f8f9fa 100%);
            border: 2px solid #CC0000;
            border-radius: 15px;
            padding: 25px;
            margin-top: 20px;
            box-shadow: 0 5px 20px rgba(204, 0, 0, 0.1);
            overflow: visible;
        }

        .msi-rec-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #CC0000;
        }

        .msi-rec-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #CC0000;
            display: flex;
            align-items: center;
        }

        .msi-rec-title::before {
            content: "üñ•Ô∏è";
            margin-right: 10px;
        }

        .msi-rec-price {
            font-size: 1.3rem;
            font-weight: 700;
            color: #CC0000;
        }

        .msi-product-image {
            width: 100%;
            max-width: 300px;
            height: auto;
            border-radius: 8px;
            margin-bottom: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            object-fit: cover;
        }

        .msi-spec-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .msi-spec-item {
            background: rgba(204, 0, 0, 0.05);
            padding: 10px 15px;
            border-radius: 8px;
            border-left: 3px solid #CC0000;
        }

        .msi-spec-label {
            font-size: 0.8rem;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .msi-spec-value {
            font-size: 0.9rem;
            font-weight: 500;
            color: #1a1a1a;
            line-height: 1.2;
        }

        .msi-buy-btn {
            background: white !important;
            background-image: none !important;
            color: #333 !important;
            text-decoration: none;
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            transition: all 0.3s ease;
            border: 2px solid #ddd;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .msi-buy-btn:hover {
            background: white !important;
            background-image: none !important;
            border-color: #CC0000;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            transform: translateY(-2px);
        }

        .msi-buy-btn .reseller-logo {
            height: 20px;
            width: auto;
            margin-left: 15px;
            object-fit: contain;
        }

        .selected-usages {
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 30px;
            border-left: 5px solid #CC0000;
            box-shadow: 
                0 5px 20px rgba(0,0,0,0.08),
                inset 0 1px 0 rgba(255,255,255,0.8);
        }

        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
            gap: 25px;
            margin-top: 25px;
        }

        .recommendations {
            display: none;
            margin-top: 35px;
        }

        .category-section {
            margin-bottom: 25px;
        }

        .loading {
            text-align: center;
            color: #666;
            font-style: italic;
        }

        @media (max-width: 768px) {
            .usage-grid {
                grid-template-columns: 1fr;
            }
            
            .config-grid {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 2.4rem;
            }
            
            .main-content, .section {
                padding: 30px 25px;
            }
            
            .header-content {
                flex-direction: column;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-content">
                <img src="https://raw.githubusercontent.com/Sam-MSI/msi-guide/main/Logos/2021-msi-series_logo-gaming.png" alt="MSI Logo" style="height: 60px; width: auto; margin-right: 20px; object-fit: contain;">
                <div class="header-title">
                    <h1>MSI - GUIDE D'ACHAT PC PORTABLE</h1>
                </div>
            </div>
        </header>

        <div class="main-content">
            <div class="section">
                <h2>1. S√©lectionnez vos usages</h2>
                <p style="margin-bottom: 25px; color: #666; line-height: 1.5;">Cliquez sur votre usage principal, puis ajoutez des usages secondaires. Un num√©ro appara√Ætra pour indiquer l'ordre de priorit√©.</p>
                
                <div class="usage-grid" id="usageGrid">
                    <div class="loading">Chargement des usages...</div>
                </div>
                
                <div style="text-align: center;">
                    <button class="generate-btn" id="generateBtn" disabled>üîç G√©n√©rer mes recommandations</button>
                    <button class="reset-btn" id="resetBtn">üîÑ R√©initialiser</button>
                </div>
            </div>

            <div class="recommendations" id="recommendations">
                <div class="section">
                    <h2>2. Vos recommandations personnalis√©es</h2>
                    <div class="selected-usages" id="selectedUsages"></div>
                    <div class="config-grid" id="configGrid"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Variables globales
        let selectedUsages = [];
        let usageSpecs = {};
        let rankings = {};
        let laptopsData = [];

        // Mapping des noms techniques vers noms fran√ßais
        const frenchLabels = {
            // Composants principaux
            'cpu': 'Processeur',
            'gpu': 'Carte graphique',
            'ram': 'M√©moire vive (RAM)',
            'ssd': 'Stockage SSD',
            
            // √âcran
            'screen_quality': 'Qualit√© d\'√©cran',
            'R√©activit√©': 'Fr√©quence de rafra√Æchissement',
            'screen_colors': 'Pr√©cision des couleurs',
            
            // Confort
            'mobility': 'Mobilit√© / Poids',
            'Silence': 'Niveau sonore',
            'Autonomie': 'Autonomie batterie',
            'Norme Wi-Fi/Bluetooth': 'Connectivit√© sans fil',
            'Pav√© num√©rique': 'Pav√© num√©rique'
        };

        // Ic√¥nes pour les cat√©gories
        const categoryIcons = {
            'COMPOSANTS PRINCIPAUX': 'üîß',
            'ECRAN': 'üñ•Ô∏è',
            'CONFORT': '‚ú®'
        };

        // Coefficients de priorit√© bas√©s sur l'ordre de s√©lection
        const getPriorityCoefficient = (order) => {
            const coefficients = [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1];
            return coefficients[order] || 0.1;
        };

        // Chargement des donn√©es depuis les APIs
        async function loadData() {
            try {
                console.log('Chargement des donn√©es...');
                
                // Chargement parall√®le des 3 APIs
                const [usageResponse, rankingResponse, laptopsResponse] = await Promise.all([
                    fetch('https://api.jsonbin.io/v3/b/68c2f2ced0ea881f407a80ff'),
                    fetch('https://api.jsonbin.io/v3/b/68c2f2dbd0ea881f407a8105'),
                    fetch('https://api.jsonbin.io/v3/b/68c2f2c043b1c97be93f90fa')
                ]);

                if (!usageResponse.ok || !rankingResponse.ok || !laptopsResponse.ok) {
                    throw new Error('Erreur lors du chargement des donn√©es');
                }

                const usageData = await usageResponse.json();
                const rankingData = await rankingResponse.json();
                const laptopsDataResponse = await laptopsResponse.json();

                usageSpecs = usageData.record || usageData;
                rankings = rankingData.record || rankingData;
                laptopsData = laptopsDataResponse.record || laptopsDataResponse;

                console.log('Donn√©es charg√©es:', {
                    usages: Object.keys(usageSpecs).length,
                    rankings: Object.keys(rankings).length,
                    laptops: laptopsData.length
                });

                renderUsageCards();
                
            } catch (error) {
                console.error('Erreur lors du chargement:', error);
                document.getElementById('usageGrid').innerHTML = '<div class="loading" style="color: #cc0000;">Erreur lors du chargement des donn√©es</div>';
            }
        }

        // Rendu des cartes d'usage
        function renderUsageCards() {
            const grid = document.getElementById('usageGrid');
            
            const cards = Object.entries(usageSpecs).map(([key, usage]) => `
                <div class="usage-card" data-usage="${key}">
                    <div class="usage-number">1</div>
                    <img src="${usage.image}" alt="${usage.name}" class="usage-icon" onerror="this.style.display='none';">
                    <div class="usage-title">${usage.name}</div>
                    <div class="usage-desc">${getUsageDescription(key)}</div>
                </div>
            `).join('');
            
            grid.innerHTML = cards;
            
            // Ajouter les √©v√©nements
            setupEventListeners();
        }

        // Obtenir la description pour un usage
        function getUsageDescription(usageKey) {
            const descriptions = {
                'navigation_internet_multimedia': 'Web, streaming, r√©seaux sociaux',
                'data_analyse': 'Analyse de donn√©es, Excel avanc√©, bases de donn√©es',
                'communication': 'Appels √† distance, Visioconf√©rence, Teams',
                'etudes_elearning': 'Cours en ligne, prise de notes, recherches acad√©miques',
                'programmation': 'D√©veloppement, IDE, compilation',
                'jeuxvideo': 'Jeux AAA, comp√©titions en ligne, streaming',
                'montage_photo': 'Suite Adobe (Photoshop, Lightroom)',
                'montage_video': 'Suite Adobe (Premiere Pro, After Effects)',
                'creation_2d': 'Suite Adobe (Illustrator, InDesign), Mod√©lisation et animation 2D professionnelle',
                'creation_3d': 'Mod√©lisation et animation 3D professionnelle',
                'beaucoup_de_deplacements': 'Besoin de mobilit√©, autonomie et l√©g√®ret√©'
            };
            return descriptions[usageKey] || 'Usage sp√©cialis√©';
        }

        // Configuration des √©v√©nements
        function setupEventListeners() {
            const cards = document.querySelectorAll('.usage-card');
            const generateBtn = document.getElementById('generateBtn');
            const resetBtn = document.getElementById('resetBtn');

            cards.forEach(card => {
                card.addEventListener('click', function() {
                    const usage = this.dataset.usage;
                    const index = selectedUsages.indexOf(usage);
                    
                    if (index > -1) {
                        // D√©s√©lectionner
                        selectedUsages.splice(index, 1);
                        this.classList.remove('selected');
                        updateNumbers();
                    } else {
                        // S√©lectionner
                        selectedUsages.push(usage);
                        this.classList.add('selected');
                        updateNumbers();
                    }
                    
                    updateGenerateButton();
                });
            });

            generateBtn.addEventListener('click', generateRecommendations);
            resetBtn.addEventListener('click', resetSelections);
        }

        function updateNumbers() {
            const cards = document.querySelectorAll('.usage-card');
            cards.forEach(card => {
                const usage = card.dataset.usage;
                const index = selectedUsages.indexOf(usage);
                const numberElement = card.querySelector('.usage-number');
                
                if (index > -1) {
                    numberElement.textContent = index + 1;
                }
            });
        }

        function updateGenerateButton() {
            document.getElementById('generateBtn').disabled = selectedUsages.length === 0;
        }

        function resetSelections() {
            selectedUsages = [];
            document.querySelectorAll('.usage-card').forEach(card => {
                card.classList.remove('selected');
            });
            document.getElementById('recommendations').style.display = 'none';
            updateGenerateButton();
        }

        function generateRecommendations() {
            const recommendations = document.getElementById('recommendations');
            const selectedUsagesDiv = document.getElementById('selectedUsages');
            const configGrid = document.getElementById('configGrid');

            // Afficher les usages s√©lectionn√©s
            let usageText = '<h3 style="margin-bottom: 15px; color: #1a1a1a;">üìã Vos usages s√©lectionn√©s :</h3>';
            selectedUsages.forEach((usage, index) => {
                const spec = usageSpecs[usage];
                const coefficient = getPriorityCoefficient(index);
                if (spec) {
                    usageText += `<div style="display: inline-block; margin: 5px 10px 5px 0; padding: 8px 15px; background: #fff; border: 2px solid #CC0000; border-radius: 25px; color: #CC0000; font-weight: 600;">
                        <span style="background: #CC0000; color: white; border-radius: 50%; width: 20px; height: 20px; display: inline-flex; align-items: center; justify-content: center; margin-right: 8px; font-size: 0.8rem;">${index + 1}</span>
                        <img src="${spec.image}" style="width: 16px; height: 16px; margin-right: 5px; vertical-align: middle;" onerror="this.style.display='none';"> ${spec.name}
                        <span class="priority-indicator">Priorit√© ${(coefficient * 100).toFixed(0)}%</span>
                    </div>`;
                }
            });
            selectedUsagesDiv.innerHTML = usageText;

            // G√©n√©rer les configurations combin√©es avec priorit√©s
            const combinedSpecs = combineSpecsWithPriority();
            configGrid.innerHTML = generateConfigCards(combinedSpecs);
            
            recommendations.style.display = 'block';
            recommendations.scrollIntoView({ behavior: 'smooth' });
        }

        function combineSpecsWithPriority() {
            // Initialiser la structure de r√©sultat
            const result = {
                minimum: {},
                recommande: {},
                ideal: {}
            };

            // Pour chaque usage s√©lectionn√©, r√©cup√©rer les specs avec leurs coefficients de priorit√©
            const allUsageSpecsWithPriority = selectedUsages.map((usage, index) => ({
                specs: usageSpecs[usage].specs,
                priority: getPriorityCoefficient(index),
                order: index
            }));

            // Pour chaque cat√©gorie
            const firstUsageSpecs = usageSpecs[selectedUsages[0]].specs;
            Object.keys(firstUsageSpecs).forEach(category => {
                result.minimum[category] = {};
                result.recommande[category] = {};
                result.ideal[category] = {};

                // Pour chaque sp√©cification dans cette cat√©gorie
                Object.keys(firstUsageSpecs[category]).forEach(specName => {
                    // Collecter toutes les valeurs pour cette spec dans tous les usages avec priorit√©s
                    const allValues = {
                        minimum: [],
                        recommande: [],
                        ideal: []
                    };

                    allUsageSpecsWithPriority.forEach(({ specs, priority, order }) => {
                        const spec = specs[category] && specs[category][specName];
                        if (spec) {
                            if (spec.minimum !== null) allValues.minimum.push({ value: spec.minimum, priority, order });
                            if (spec.recommande !== null) allValues.recommande.push({ value: spec.recommande, priority, order });
                            if (spec.ideal !== null) allValues.ideal.push({ value: spec.ideal, priority, order });
                        }
                    });

                    // Prendre la valeur la plus exigeante en tenant compte des priorit√©s
                    result.minimum[category][specName] = {
                        minimum: getMostDemandingWithPriority(allValues.minimum, specName)
                    };
                    result.recommande[category][specName] = {
                        recommande: getMostDemandingWithPriority(allValues.recommande, specName)
                    };
                    result.ideal[category][specName] = {
                        ideal: getMostDemandingWithPriority(allValues.ideal, specName)
                    };
                });
            });

            return result;
        }

        function getMostDemandingWithPriority(values, specType) {
            if (!values || values.length === 0) return null;
            if (values.length === 1) return values[0].value;

            // Filtrer les valeurs nulles
            const validValues = values.filter(v => v.value !== null);
            if (validValues.length === 0) return null;
            if (validValues.length === 1) return validValues[0].value;

            // Trier par priorit√© (ordre de s√©lection) d'abord
            validValues.sort((a, b) => a.order - b.order);

            // Logique de comparaison selon le type de sp√©cification avec priorit√©
            const result = validValues.reduce((most, current) => {
                // Si c'est le premier usage (priorit√© maximale), il a plus de poids
                if (current.order === 0) {
                    if (isMoreDemanding(current.value, most.value, specType)) {
                        return current;
                    }
                    // M√™me si current n'est pas plus exigeant, il garde une influence forte
                    if (current.priority >= 0.8) {
                        return current;
                    }
                }
                
                // Pour les autres usages, appliquer la logique normale mais avec coefficient
                if (isMoreDemanding(current.value, most.value, specType) && current.priority > 0.5) {
                    return current;
                }
                return most;
            });
            
            return result.value;
        }

        function isMoreDemanding(value1, value2, specType) {
            if (!value1 || !value2) return !!value1;

            const spec = specType.toLowerCase();
            
            // CPU - Utiliser le classement
            if (spec.includes('cpu')) {
                const rank1 = getRankingPosition(value1, rankings.cpu);
                const rank2 = getRankingPosition(value2, rankings.cpu);
                return rank1 < rank2; // Plus le rang est petit, plus c'est puissant
            }
            
            // GPU - Utiliser le classement
            if (spec.includes('gpu')) {
                const rank1 = getRankingPosition(value1, rankings.gpu);
                const rank2 = getRankingPosition(value2, rankings.gpu);
                return rank1 < rank2;
            }
            
            // RAM - Extraire les GB
            if (spec.includes('ram')) {
                const gb1 = extractNumber(value1);
                const gb2 = extractNumber(value2);
                if (gb1 !== gb2) return gb1 > gb2;
                return value1.includes('DDR5') && value2.includes('DDR4');
            }
            
            // SSD - Extraire la capacit√©
            if (spec.includes('ssd')) {
                const size1 = extractStorageSize(value1);
                const size2 = extractStorageSize(value2);
                if (size1 !== size2) return size1 > size2;
                return value1.includes('PCIe 5.0') && value2.includes('PCIe 4.0');
            }
            
            // √âcran - Utiliser le classement
            if (spec.includes('screen_quality')) {
                const rank1 = getRankingPosition(value1, rankings.screen_quality);
                const rank2 = getRankingPosition(value2, rankings.screen_quality);
                return rank1 < rank2;
            }
            
            if (spec.includes('screen_colors')) {
                const rank1 = getRankingPosition(value1, rankings.screen_colors);
                const rank2 = getRankingPosition(value2, rankings.screen_colors);
                return rank1 < rank2;
            }
            
            // Fr√©quence Hz
            if (spec.includes('r√©activit√©') || spec.includes('hz')) {
                const hz1 = extractNumber(value1);
                const hz2 = extractNumber(value2);
                return hz1 > hz2;
            }
            
            // Wi-Fi
            if (spec.includes('wi-fi')) {
                const wifiVersions = { 'wi-fi 6': 1, 'wi-fi 6e': 2, 'wi-fi 7': 3 };
                const wifi1 = wifiVersions[value1.toLowerCase()] || 0;
                const wifi2 = wifiVersions[value2.toLowerCase()] || 0;
                return wifi1 > wifi2;
            }
            
            return false;
        }

        function getRankingPosition(value, rankingArray) {
            if (!rankingArray || !value) return 999;
            
            // Comparaison directe puisque les valeurs sont harmonis√©es
            const position = rankingArray.findIndex(item => item === value);
            
            console.log(`Ranking pour "${value}": position ${position}`);
            return position === -1 ? 999 : position;
        }

        function extractNumber(str) {
            if (!str) return 0;
            const match = str.match(/(\d+)/);
            return match ? parseInt(match[1]) : 0;
        }

        function extractStorageSize(storage) {
            if (!storage) return 0;
            if (storage.includes('To')) {
                return extractNumber(storage) * 1000;
            }
            return extractNumber(storage);
        }

        function calculateFallbackDistance(laptopValue, requiredValue, specName) {
            if (!laptopValue || !requiredValue) return 1000;
            
            // CPU/GPU/√âcran - Utiliser les positions dans le ranking
            if (specName === 'cpu' || specName === 'gpu' || specName === 'screen_quality' || specName === 'screen_colors') {
                const rankingArray = rankings[specName] || (specName.includes('screen') ? rankings.screen_quality : rankings.cpu);
                const laptopRank = getRankingPosition(laptopValue, rankingArray);
                const requiredRank = getRankingPosition(requiredValue, rankingArray);
                
                if (laptopRank === 999 || requiredRank === 999) return 1000;
                
                // Retourner la diff√©rence absolue (m√™me si laptop est moins bon)
                return Math.abs(laptopRank - requiredRank);
            }
            
            // RAM - Utiliser les GB
            if (specName === 'ram') {
                const laptopGB = extractNumber(laptopValue);
                const requiredGB = extractNumber(requiredValue);
                
                // Retourner la diff√©rence absolue en paliers de 8GB
                return Math.abs(laptopGB - requiredGB) / 8;
            }
            
            // SSD - Utiliser la capacit√©
            if (specName === 'ssd') {
                const laptopSize = extractStorageSize(laptopValue);
                const requiredSize = extractStorageSize(requiredValue);
                
                // Retourner la diff√©rence absolue en paliers de 256GB
                return Math.abs(laptopSize - requiredSize) / 256;
            }
            
            return 10; // Distance par d√©faut pour les autres specs
        }

        function findMatchingLaptop(specs, level) {
            let bestMatch = null;
            let smallestDistance = Infinity;

            console.log(`\nüîç Recherche du laptop le plus proche pour: ${level}`);

            // Premier passage : chercher les laptops qui respectent les crit√®res
            laptopsData.forEach((laptop, index) => {
                // Filtrer la console Claw si l'usage "jeuxvideo" n'est pas s√©lectionn√©
                if (laptop.name.startsWith('Claw') && !selectedUsages.includes('jeuxvideo')) {
                    console.log(`‚ö†Ô∏è ${laptop.name} exclue car usage "Jeux-vid√©o" non s√©lectionn√©`);
                    return; // Passer au laptop suivant
                }

                let totalDistance = 0;
                let distanceDetails = [];
                let isValid = true;
                
                // Calculer la distance pour chaque spec importante
                const categories = specs[level];
                Object.keys(categories).forEach(category => {
                    Object.keys(categories[category]).forEach(specName => {
                        const requiredValue = categories[category][specName][level];
                        if (requiredValue && laptop.specs[specName]) {
                            const distance = calculateDistance(laptop.specs[specName], requiredValue, specName);
                            if (distance === -1) {
                                isValid = false; // Le laptop ne r√©pond pas aux exigences minimales
                            } else {
                                totalDistance += distance;
                                distanceDetails.push(`${specName}: ${distance}`);
                            }
                        }
                    });
                });

                if (isValid) {
                    console.log(`${laptop.name}: Distance totale ${totalDistance} (${distanceDetails.join(', ')})`);

                    if (totalDistance < smallestDistance) {
                        smallestDistance = totalDistance;
                        bestMatch = laptop;
                    }
                }
            });

            // Si aucun laptop ne correspond, prendre le plus proche m√™me en dessous des crit√®res
            if (!bestMatch) {
                console.log("üîÑ Aucun laptop ne respecte les crit√®res, recherche du plus proche...");
                smallestDistance = Infinity;
                
                laptopsData.forEach((laptop, index) => {
                    // Filtrer la console Claw si l'usage "jeuxvideo" n'est pas s√©lectionn√© (m√™me en fallback)
                    if (laptop.name.startsWith('Claw') && !selectedUsages.includes('jeuxvideo')) {
                        console.log(`‚ö†Ô∏è ${laptop.name} exclue en fallback car usage "Jeux-vid√©o" non s√©lectionn√©`);
                        return; // Passer au laptop suivant
                    }

                    let totalDistance = 0;
                    let distanceDetails = [];
                    
                    // Calculer la distance pour chaque spec importante (sans exclusion)
                    const categories = specs[level];
                    Object.keys(categories).forEach(category => {
                        Object.keys(categories[category]).forEach(specName => {
                            const requiredValue = categories[category][specName][level];
                            if (requiredValue && laptop.specs[specName]) {
                                let distance = calculateDistance(laptop.specs[specName], requiredValue, specName);
                                // Convertir les distances n√©gatives en distances positives pour la comparaison
                                if (distance === -1) {
                                    distance = calculateFallbackDistance(laptop.specs[specName], requiredValue, specName);
                                }
                                totalDistance += Math.abs(distance);
                                distanceDetails.push(`${specName}: ${distance}`);
                            }
                        });
                    });

                    console.log(`${laptop.name} (fallback): Distance totale ${totalDistance} (${distanceDetails.join(', ')})`);

                    if (totalDistance < smallestDistance) {
                        smallestDistance = totalDistance;
                        bestMatch = laptop;
                    }
                });
            }

            console.log(`üèÜ Meilleur match: ${bestMatch?.name} avec une distance de ${smallestDistance}`);
            return bestMatch;
        }

        function calculateDistance(laptopValue, requiredValue, specName) {
            if (!laptopValue || !requiredValue) return -1;
            
            // Condition sp√©ciale pour les GPUs int√©gr√©s
            if (specName === 'gpu') {
                const integratedGPUs = [
                    "Intel Arc 140V GPU",
                    "Intel Arc 140T GPU", 
                    "Integree : Intel Arc graphics 8 Cores",
                    "Integree : Intel UHD Graphics"
                ];
                
                // Si l'usage demande un GPU int√©gr√©, le laptop doit aussi avoir un GPU int√©gr√©
                if (integratedGPUs.includes(requiredValue)) {
                    if (!integratedGPUs.includes(laptopValue)) {
                        console.log(`  GPU: Exclusion - Usage demande int√©gr√© "${requiredValue}" mais laptop a d√©di√© "${laptopValue}"`);
                        return -1; // Exclure les GPUs d√©di√©s quand on veut de l'int√©gr√©
                    }
                }
            }
            
            // CPU/GPU/√âcran - Utiliser les positions dans le ranking
            if (specName === 'cpu' || specName === 'gpu' || specName === 'screen_quality' || specName === 'screen_colors') {
                const rankingArray = rankings[specName] || (specName.includes('screen') ? rankings.screen_quality : rankings.cpu);
                const laptopRank = getRankingPosition(laptopValue, rankingArray);
                const requiredRank = getRankingPosition(requiredValue, rankingArray);
                
                if (laptopRank === 999 || requiredRank === 999) return -1;
                if (laptopRank > requiredRank) return -1; // Laptop moins bon que requis
                
                return requiredRank - laptopRank; // Distance = nombre de positions en dessus
            }
            
            // RAM - Utiliser les GB
            if (specName === 'ram') {
                const laptopGB = extractNumber(laptopValue);
                const requiredGB = extractNumber(requiredValue);
                
                if (laptopGB < requiredGB) return -1; // Pas assez de RAM
                return Math.floor((laptopGB - requiredGB) / 8); // Distance par paliers de 8GB
            }
            
            // SSD - Utiliser la capacit√©
            if (specName === 'ssd') {
                const laptopSize = extractStorageSize(laptopValue);
                const requiredSize = extractStorageSize(requiredValue);
                
                if (laptopSize < requiredSize) return -1; // Pas assez de stockage
                return Math.floor((laptopSize - requiredSize) / 256); // Distance par paliers de 256GB
            }
            
            return 0; // Distance nulle pour les autres specs
        }

        function getSpecWeight(specName) {
            const weights = {
                'cpu': 25,
                'gpu': 30,
                'ram': 20,
                'ssd': 15,
                'screen_quality': 10,
                'screen_colors': 5,
                'mobility': 8
            };
            return weights[specName] || 5;
        }

        function generateMSIRecommendation(laptop) {
            if (!laptop) return '';

            // Mapping des noms de revendeurs pour l'affichage
            const resellerNames = {
                'MSI-Store': 'MSI',
                'LDLC': 'LDLC',
                'Boulanger': 'Boulanger',
                'Fnac': 'Fnac'
            };
            
            const resellerName = resellerNames[laptop.reseller] || laptop.reseller;
            
            return `
                <div class="msi-recommendation">
                    <div class="msi-rec-header">
                        <div class="msi-rec-title">${laptop.name}</div>
                        <div class="msi-rec-price">${laptop.specs.price}‚Ç¨</div>
                    </div>
                    
                    ${laptop.image ? `<img src="${laptop.image}" alt="${laptop.name}" class="msi-product-image" onerror="this.style.display='none'">` : ''}
                    
                    <div class="msi-spec-grid">
                        <div class="msi-spec-item">
                            <div class="msi-spec-label">Processeur</div>
                            <div class="msi-spec-value">${laptop.specs.cpu ? laptop.specs.cpu.split(' ').slice(0, 4).join(' ') : 'N/A'}</div>
                        </div>
                        <div class="msi-spec-item">
                            <div class="msi-spec-label">Carte graphique</div>
                            <div class="msi-spec-value">${laptop.specs.gpu ? laptop.specs.gpu.replace(/NVIDIA¬Æ?\s*GeForce\s*/i, '').replace(/¬Æ|‚Ñ¢/g, '') : 'N/A'}</div>
                        </div>
                        <div class="msi-spec-item">
                            <div class="msi-spec-label">M√©moire RAM</div>
                            <div class="msi-spec-value">${laptop.specs.ram ? laptop.specs.ram.split(' ').slice(0, 3).join(' ') : 'N/A'}</div>
                        </div>
                        <div class="msi-spec-item">
                            <div class="msi-spec-label">Stockage</div>
                            <div class="msi-spec-value">${laptop.specs.ssd || 'N/A'}</div>
                        </div>
                        <div class="msi-spec-item">
                            <div class="msi-spec-label">√âcran</div>
                            <div class="msi-spec-value">${laptop.specs.screen_quality || 'N/A'}${laptop.specs.screen_refresh ? ' - ' + laptop.specs.screen_refresh : ''}</div>
                        </div>
                        <div class="msi-spec-item">
                            <div class="msi-spec-label">Poids</div>
                            <div class="msi-spec-value">${laptop.specs.mobility || 'N/A'}</div>
                        </div>
                    </div>
                    
                    <a href="${laptop.specs.link}" target="_blank" class="msi-buy-btn">
                        Voir chez ${resellerName}
                    </a>
                </div>
            `;
        }

        function generateConfigCards(specs) {
            const levels = [
                { key: 'minimum', title: 'Configuration Minimum', description: 'Pour d√©buter avec un budget serr√©' },
                { key: 'recommande', title: 'Configuration Recommand√©e', description: 'Le meilleur √©quilibre performance/prix' },
                { key: 'ideal', title: 'Configuration Id√©ale', description: 'Pour une exp√©rience optimale sans compromis' }
            ];

            return levels.map(level => {
                const spec = specs[level.key];
                
                // Trouver le PC MSI correspondant
                const matchingLaptop = findMatchingLaptop(specs, level.key);
                
                return `
                    <div class="config-card ${level.key}">
                        <div class="config-title">${level.title}</div>
                        <p style="color: #666; margin-bottom: 25px; font-size: 0.95rem; line-height: 1.4;">${level.description}</p>
                        
                        ${Object.entries(spec).map(([category, categorySpecs]) => {
                            // Filtrer les specs qui ont des valeurs non-nulles pour cette cat√©gorie
                            const validSpecs = Object.entries(categorySpecs).filter(([specName, values]) => {
                                const value = values[level.key];
                                return value !== null && value !== undefined && value !== '';
                            });

                            // Si aucune spec valide dans cette cat√©gorie, ne pas afficher la cat√©gorie
                            if (validSpecs.length === 0) {
                                return '';
                            }

                            return `
                                <div class="category-section">
                                    <div class="category-title" data-category="${category}">
                                        ${categoryIcons[category] || 'üîß'} ${category}
                                    </div>
                                    ${validSpecs.map(([specName, values]) => {
                                        const value = values[level.key];
                                        const displayName = frenchLabels[specName] || specName;
                                        return `
                                            <div class="spec-item">
                                                <div class="spec-label">${displayName}</div>
                                                <div class="spec-value">${value}</div>
                                            </div>
                                        `;
                                    }).join('')}
                                </div>
                            `;
                        }).join('')}
                        
                        ${matchingLaptop ? generateMSIRecommendation(matchingLaptop) : ''}
                    </div>
                `;
            }).join('');
        }

        // Initialisation au chargement de la page
        document.addEventListener('DOMContentLoaded', function() {
            loadData();
        });
    </script>
</body>
</html>
